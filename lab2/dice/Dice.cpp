#include "Dice.h"

#include <stdexcept>
#include <random>
#include <chrono>

namespace dice {
    // Private methods
    void Dice::initRNG() {
        uint64_t timeSeed = std::chrono::high_resolution_clock::now().time_since_epoch().count();
        std::seed_seq ss{uint32_t(timeSeed & 0xffffffff), uint32_t(timeSeed>>32)};
        m_rng.seed(ss);
        m_dist = std::uniform_real_distribution<double>(0.0, 1.0);
    }

    int Dice::genWithDistrib() {
        double rnum = m_dist(m_rng);

        for (int i = 0; i < 6; ++i) {
            if (rnum < m_probs[i]) {
                return i;
            } else {
                rnum -= m_probs[i];
            }
        }

        throw std::runtime_error("Invalid value generated by RNG!");
    }

    bool Dice::check_probs(const double probs[6]) {
        if (probs == nullptr) {
            return false;
        }

        double sum = 0.0;
        for (int i = 0; i < 6; ++i) {
            if (probs[i] < 0.0 || probs[i] > 1.0) {
                return false;
            }
            sum += probs[i];
        }

        if (fabs(sum - 1.0) > eps) {
            return false;
        }

        return true;
    }

    // Constructors
    Dice::Dice() {
        m_value = 1;
        for (int i = 0; i < 6; ++i) {
            m_probs[i] = d_probs[i];
        }
    }

    Dice::Dice(int val, double probs[6]) {
        initRNG();

        if (val < 1 || val > 6) {
            throw std::invalid_argument("Invalid value for roll!");
        }

        if (!check_probs(probs)) {
            throw std::invalid_argument("Invalid values for probabilities!");
        }

        for (int i = 0; i < 6; ++i) {
            m_probs[i] = probs[i];
        }

        m_value = val;
    }

    Dice::Dice(bool random, double probs[6]) {
        initRNG();

        if (!check_probs(probs)) {
            throw std::invalid_argument("Invalid values for probabilities!");
        }

        for (int i = 0; i < 6; ++i) {
            m_probs[i] = probs[i];
        }

        m_value = random ? genWithDistrib() : 1;
    }

    // Getters
    int Dice::getVal() const {
        return m_value;
    }

    const double *Dice::getProbs() const {
        return m_probs;
    }

    // Setters
    void Dice::setVal(int val) {
        if (val < 1 || val > 6) {
            throw std::invalid_argument("Invalid value for dice!");
        }

        m_value = val;
    }

    void Dice::setProbs(const double probs[6]) {
        if (!check_probs(probs)) {
            throw std::invalid_argument("Invalid values for probabilities!");
        }

        for (int i = 0; i < 6; ++i) {
            m_probs[i] = d_probs[i];
        }
    }

    // Methods
    void Dice::roll() {
        m_value = genWithDistrib();
    }

    std::string Dice::getAscii() const {
        return asciis[m_value - 1];
    }

    bool operator== (const Dice &d, const Dice &other) {
        return d.getVal() == other.getVal();
    }

    std::ostream &operator<< (std::ostream &out, const Dice& dice) {
        out << "Roll value is: " << dice.getVal() << '\n';
        out << "Probabilities are: { ";

        const double *ptr = dice.getProbs();
        for (int i = 0; i < 6; ++i) {
            out << ptr[i] << ' ';
        }

        out << "}\n";
        return out;
    }

    std::istream &operator>> (std::istream &in, Dice &dice) {
        int val;
        in >> val;

        double new_probs[6];
        for (double & new_prob : new_probs) {
            in >> new_prob;
        }

        dice.setProbs(new_probs);
        dice.setVal(val);

        return in;
    }
}
